import org.junit.jupiter.api.parallel.Execution;
import org.junit.jupiter.api.parallel.ExecutionMode;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.TestContext;
import org.springframework.test.context.TestExecutionListener;
import org.springframework.test.context.support.AbstractTestExecutionListener;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class MockBeanTestExecutionListener extends AbstractTestExecutionListener {

    @Override
    public void beforeTestClass(TestContext testContext) throws Exception {
        if (containsMockBean(testContext.getTestClass())) {
            disableParallelExecution(testContext.getTestClass());
        }
    }

    @Override
    public void beforeTestMethod(TestContext testContext) throws Exception {
        if (containsMockBean(testContext.getTestMethod())) {
            disableParallelExecution(testContext.getTestMethod());
        }
    }

    private boolean containsMockBean(Class<?> testClass) {
        for (Field field : testClass.getDeclaredFields()) {
            if (field.isAnnotationPresent(MockBean.class)) {
                return true;
            }
        }
        return false;
    }

    private boolean containsMockBean(Method testMethod) {
        for (Field field : testMethod.getDeclaringClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MockBean.class)) {
                return true;
            }
        }
        return false;
    }

    private void disableParallelExecution(Class<?> testClass) {
        if (!testClass.isAnnotationPresent(Execution.class)) {
            testClass.getDeclaredAnnotations().add(Execution.class.getAnnotation(ExecutionMode.SAME_THREAD));
        }
    }

    private void disableParallelExecution(Method testMethod) {
        if (!testMethod.isAnnotationPresent(Execution.class)) {
            testMethod.getDeclaredAnnotations().add(Execution.class.getAnnotation(ExecutionMode.SAME_THREAD));
        }
    }
}
