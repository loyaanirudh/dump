import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.context.TestContext;
import org.springframework.test.context.support.AbstractTestExecutionListener;
import org.junit.platform.engine.support.hierarchical.ParallelExecutionConfigurationStrategy;
import org.junit.platform.engine.support.hierarchical.ParallelExecutionConfiguration;
import org.junit.platform.engine.ConfigurationParameters;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Optional;

public class MockBeanTestExecutionListener extends AbstractTestExecutionListener {

    @Override
    public void beforeTestClass(TestContext testContext) throws Exception {
        if (containsMockBean(testContext.getTestClass())) {
            setSequentialExecution(testContext);
        }
    }

    @Override
    public void beforeTestMethod(TestContext testContext) throws Exception {
        if (containsMockBean(testContext.getTestMethod())) {
            setSequentialExecution(testContext);
        }
    }

    private boolean containsMockBean(Class<?> testClass) {
        for (Field field : testClass.getDeclaredFields()) {
            if (field.isAnnotationPresent(MockBean.class)) {
                return true;
            }
        }
        return false;
    }

    private boolean containsMockBean(Method testMethod) {
        for (Field field : testMethod.getDeclaringClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MockBean.class)) {
                return true;
            }
        }
        return false;
    }

    private void setSequentialExecution(TestContext testContext) {
        // Custom logic to set the execution mode to same thread (sequential execution)
        System.setProperty("junit.jupiter.execution.parallel.enabled", "false");
    }
}
